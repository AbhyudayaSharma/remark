'use strict';

/**
 * Eslint's formatter API expects `filePath` to be a
 * string.  This hacky way supports invocation as well as
 * implicit coercion.
 *
 * @param {File} file
 * @return {Function}
 */
function filePathFactory(file) {
    /**
     * Get the location of `file`.
     *
     * Returns empty string when without `filename`.
     *
     * @return {string}
     */
    function filePath() {
        var directory;

        if (file.filename) {
            directory = file.directory;

            if (directory.charAt(directory.length - 1) === '/') {
                directory = directory.slice(0, -1);
            }

            if (directory === '.') {
                directory = '';
            }

            return (directory ? directory + '/' : '') +
                file.filename +
                (file.extension ? '.' + file.extension : '');
        }

        return '';
    }

    filePath.toString = filePath;

    return filePath;
}

/**
 * Construct a new file.
 *
 * @constructor
 * @class {File}
 * @param {Object|File|string} [options]
 */
function File(options) {
    var self = this;

    if (!(self instanceof File)) {
        return new File(options);
    }

    if (options instanceof File) {
        return options;
    }

    if (!options) {
        options = {};
    } else if (typeof options === 'string') {
        options = {
            'contents': options
        };
    }

    self.filename = options.filename || null;
    self.contents = options.contents || '';

    self.directory = options.directory === undefined ? '' : options.directory;

    self.extension = options.extension === undefined ?
        'md' : options.extension;

    self.messages = [];

    /*
     * Make sure eslintâ€™s formatters stringify `filePath` properly.
     */

    self.filePath = filePathFactory(self);
}

/**
 * Stringify a position.
 *
 * @param {Object?} [position]
 * @return {string}
 */
function stringify(position) {
    if (!position) {
        position = {};
    }

    return (position.line || 1) + ':' + (position.column || 1);
}

/**
 * Warn.
 *
 * @this {File}
 * @param {string} reason
 * @param {Node|Location|Position} [position]
 * @return {Error}
 */
function warn(reason, position) {
    var err = this.exception(reason, position);

    err.fatal = false;

    this.messages.push(err);

    return err;
}

/**
 * Fail.
 *
 * @this {File}
 * @param {string} reason
 * @param {Node|Location|Position} [position]
 * @return {Error}
 * @throws {Error} - When not `quiet: true`.
 */
function fail(reason, position) {
    var err = this.exception(reason, position);

    err.fatal = true;

    this.messages.push(err);

    if (!this.quiet) {
        throw err;
    }

    return err;
}

/**
 * Create an exception with `reason` at `position`.
 *
 * @this {File}
 * @param {string|Error} reason
 * @param {Node|Location|Position} [position]
 * @return {Error}
 */
function exception(reason, position) {
    var file = this.filePath();
    var location;
    var err;

    /*
     * Node / location / position.
     */

    if (position && position.position) {
        position = position.position;
    }

    if (position && position.start) {
        location = stringify(position.start) + '-' + stringify(position.end);
        position = position.start;
    } else {
        location = stringify(position);
    }

    err = new Error(reason.message || reason);

    err.name = (file ? file + ':' : '') + location;
    err.file = file;
    err.reason = reason;
    err.line = position ? position.line : null;
    err.column = position ? position.column : null;

    if (reason.stack) {
        err.stack = reason.stack;
    }

    return err;
}

/**
 * Check if `file` has a fatal message.
 *
 * @this {File}
 * @return {boolean}
 */
function hasFailed() {
    var messages = this.messages;
    var index = -1;
    var length = messages.length;

    while (++index < length) {
        if (messages[index].fatal) {
            return true;
        }
    }

    return false;
}

/**
 * Create a string representation of `file`.
 *
 * @this {File}
 * @return {string}
 */
function toString() {
    return this.contents;
}

/*
 * Methods.
 */

File.prototype.exception = exception;
File.prototype.toString = toString;
File.prototype.warn = warn;
File.prototype.fail = fail;
File.prototype.hasFailed = hasFailed;

/*
 * Expose.
 */

module.exports = File;
